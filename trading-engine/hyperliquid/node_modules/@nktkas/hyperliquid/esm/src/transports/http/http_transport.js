import { TransportError } from "../../base.js";
/**
 * Error thrown when an HTTP response is deemed invalid:
 * - Non-200 status code
 * - Unexpected content type
 */
export class HttpRequestError extends TransportError {
    /**
     * Creates a new HTTP request error.
     * @param response - The failed HTTP response.
     * @param responseBody - The raw response body content, if available.
     */
    constructor(response, responseBody) {
        let message = `HTTP request failed: status ${response.status}`;
        if (responseBody)
            message += `, body "${responseBody}"`;
        super(message);
        Object.defineProperty(this, "response", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: response
        });
        Object.defineProperty(this, "responseBody", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: responseBody
        });
        this.name = "HttpRequestError";
    }
}
/** HTTP implementation of the REST transport interface. */
export class HttpTransport {
    /**
     * Creates a new HTTP transport instance.
     * @param options - Configuration options for the HTTP transport layer.
     */
    constructor(options) {
        Object.defineProperty(this, "isTestnet", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "timeout", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "server", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "fetchOptions", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "onRequest", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "onResponse", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.isTestnet = options?.isTestnet ?? false;
        this.timeout = options?.timeout === undefined ? 10_000 : options.timeout;
        this.server = {
            mainnet: {
                api: options?.server?.mainnet?.api ?? "https://api.hyperliquid.xyz",
                rpc: options?.server?.mainnet?.rpc ?? "https://rpc.hyperliquid.xyz",
            },
            testnet: {
                api: options?.server?.testnet?.api ?? "https://api.hyperliquid-testnet.xyz",
                rpc: options?.server?.testnet?.rpc ?? "https://rpc.hyperliquid-testnet.xyz",
            },
        };
        this.fetchOptions = options?.fetchOptions ?? {};
        this.onRequest = options?.onRequest;
        this.onResponse = options?.onResponse;
    }
    /**
     * Sends a request to the Hyperliquid API via fetch.
     * @param endpoint - The API endpoint to send the request to.
     * @param payload - The payload to send with the request.
     * @param signal - An optional abort signal.
     * @returns A promise that resolves with parsed JSON response body.
     * @throws {HttpRequestError} - Thrown when an HTTP response is deemed invalid.
     * @throws May throw {@link https://developer.mozilla.org/en-US/docs/Web/API/Window/fetch#exceptions | fetch errors}.
     */
    async request(endpoint, payload, signal) {
        // Construct a Request
        const url = new URL(endpoint, this.server[this.isTestnet ? "testnet" : "mainnet"][endpoint === "explorer" ? "rpc" : "api"]);
        const init = mergeRequestInit({
            body: JSON.stringify(payload),
            headers: {
                "Accept-Encoding": "gzip, deflate, br, zstd",
                "Connection": "keep-alive",
                "Content-Type": "application/json",
            },
            keepalive: true,
            method: "POST",
            signal: this.timeout ? AbortSignal.timeout(this.timeout) : undefined,
        }, this.fetchOptions, { signal });
        let request = new Request(url, init);
        // Call the onRequest callback, if provided
        if (this.onRequest) {
            const customRequest = await this.onRequest(request);
            if (customRequest instanceof Request)
                request = customRequest;
        }
        // Send the Request and wait for a Response
        let response = await fetch(request);
        // Call the onResponse callback, if provided
        if (this.onResponse) {
            const customResponse = await this.onResponse(response);
            if (customResponse instanceof Response)
                response = customResponse;
        }
        // Validate the Response
        if (!response.ok || !response.headers.get("Content-Type")?.includes("application/json")) {
            // Unload the response body to prevent memory leaks
            const body = await response.text().catch(() => undefined);
            throw new HttpRequestError(response, body);
        }
        // Parse the response body
        const body = await response.json();
        // Check if the response is an error
        if (body?.type === "error") {
            throw new HttpRequestError(response, body?.message);
        }
        // Return the response body
        return body;
    }
}
/**
 * Merges multiple `HeadersInit` objects into one.
 * @param inits - A list of `HeadersInit` objects to merge.
 * @returns A new `Headers` object that contains all headers from the input objects.
 */
function mergeHeadersInit(...inits) {
    if (inits.length === 0 || inits.length === 1) {
        return new Headers(inits[0]);
    }
    const merged = new Headers();
    for (const headers of inits) {
        const entries = Symbol.iterator in headers ? headers : Object.entries(headers);
        for (const [key, value] of entries) {
            merged.set(key, value);
        }
    }
    return merged;
}
/**
 * Merges multiple `RequestInit` objects into one.
 * @param inits - A list of `RequestInit` objects to merge.
 * @returns A new `RequestInit` object that contains all properties from the input objects.
 */
function mergeRequestInit(...inits) {
    const merged = inits.reduce((acc, init) => ({ ...acc, ...init }), {});
    const headersList = inits.map((init) => init.headers)
        .filter((headers) => typeof headers === "object");
    if (headersList.length > 0) {
        merged.headers = mergeHeadersInit(...headersList);
    }
    const signals = inits.map((init) => init.signal)
        .filter((signal) => signal instanceof AbortSignal);
    if (signals.length > 0) {
        merged.signal = signals.length > 1 ? AbortSignal.any(signals) : signals[0];
    }
    return merged;
}
