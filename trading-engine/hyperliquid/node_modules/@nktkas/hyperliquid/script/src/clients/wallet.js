(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "../base.js", "../signing.js"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WalletClient = exports.ApiRequestError = void 0;
    const base_js_1 = require("../base.js");
    const signing_js_1 = require("../signing.js");
    /** Error thrown when the API returns an error response. */
    class ApiRequestError extends base_js_1.HyperliquidError {
        constructor(response) {
            let message = "Cannot process API request";
            if (response.status === "err") {
                // For ErrorResponse
                message += `: ${response.response}`;
            }
            else {
                if ("statuses" in response.response.data) {
                    // For OrderResponse, CancelResponse
                    const errors = response.response.data.statuses.reduce((acc, status, index) => {
                        if (typeof status === "object" && "error" in status) {
                            acc.push(`Order ${index} failed: ${status.error}`);
                        }
                        return acc;
                    }, []);
                    if (errors.length > 0) {
                        message += `: ${errors.join(", ")}`;
                    }
                }
                else {
                    // For TwapOrderResponse, TwapCancelResponse
                    if (typeof response.response.data.status === "object" && "error" in response.response.data.status) {
                        message += `: ${response.response.data.status.error}`;
                    }
                }
            }
            super(message);
            Object.defineProperty(this, "response", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: response
            });
            this.name = "ApiRequestError";
        }
    }
    exports.ApiRequestError = ApiRequestError;
    /** Nonce manager for generating unique nonces for signing transactions. */
    class NonceManager {
        constructor() {
            /** The last nonce used for signing transactions. */
            Object.defineProperty(this, "lastNonce", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 0
            });
        }
        /**
         * Gets the next nonce for signing transactions.
         * @returns The next nonce.
         */
        getNonce() {
            let nonce = Date.now();
            if (nonce <= this.lastNonce) {
                nonce = ++this.lastNonce;
            }
            else {
                this.lastNonce = nonce;
            }
            return nonce;
        }
    }
    /**
     * Wallet client for interacting with the Hyperliquid API.
     * @typeParam T The transport used to connect to the Hyperliquid API.
     * @typeParam W The WalletClient/Account ([viem](https://viem.sh/docs/clients/wallet)) or Signer ([ethers.js](https://docs.ethers.io/v6/api/providers/#Signer)) used for signing transactions.
     */
    class WalletClient {
        /**
         * Initialises a new instance.
         * @param args - The parameters for the client.
         *
         * @example Private key via [viem](https://viem.sh/docs/clients/wallet#local-accounts-private-key-mnemonic-etc)
         * ```ts
         * import * as hl from "@nktkas/hyperliquid";
         * import { privateKeyToAccount } from "viem/accounts";
         *
         * const wallet = privateKeyToAccount("0x...");
         *
         * const transport = new hl.HttpTransport(); // or WebSocketTransport
         * const client = new hl.WalletClient({ wallet, transport });
         * ```
         *
         * @example Private key via [ethers.js](https://docs.ethers.org/v6/api/wallet/#Wallet) or [ethers.js v5](https://docs.ethers.org/v5/api/signer/#Wallet)
         * ```ts
         * import * as hl from "@nktkas/hyperliquid";
         * import { ethers } from "ethers";
         *
         * const wallet = new ethers.Wallet("0x...");
         *
         * const transport = new hl.HttpTransport(); // or WebSocketTransport
         * const client = new hl.WalletClient({ wallet, transport });
         * ```
         *
         * @example External wallet (e.g. MetaMask) via [viem](https://viem.sh/docs/clients/wallet#optional-hoist-the-account)
         * ```ts
         * import * as hl from "@nktkas/hyperliquid";
         * import { createWalletClient, custom } from "viem";
         *
         * const [account] = await window.ethereum.request({ method: "eth_requestAccounts" });
         * const wallet = createWalletClient({ account, transport: custom(window.ethereum) });
         *
         * const transport = new hl.HttpTransport(); // or WebSocketTransport
         * const client = new hl.WalletClient({ wallet, transport });
         * ```
         *
         * @example External wallet (e.g. MetaMask) via `window.ethereum` directly
         * ```ts
         * import * as hl from "@nktkas/hyperliquid";
         *
         * const transport = new hl.HttpTransport(); // or WebSocketTransport
         * const client = new hl.WalletClient({ wallet: window.ethereum, transport });
         * ```
         */
        constructor(args) {
            /** The transport used to connect to the Hyperliquid API. */
            Object.defineProperty(this, "transport", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            /** The `viem`, `ethers.js`, or `window.ethereum` wallet used for signing transactions. */
            Object.defineProperty(this, "wallet", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            /** Specifies whether the client uses testnet. */
            Object.defineProperty(this, "isTestnet", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            /** Sets a default vaultAddress to be used if no vaultAddress is explicitly passed to a method. */
            Object.defineProperty(this, "defaultVaultAddress", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            /** Sets a default expiresAfter to be used if no expiresAfter is explicitly passed to a method. */
            Object.defineProperty(this, "defaultExpiresAfter", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            /**
             * The network that will be used to sign transactions.
             * Must match the network of the {@link wallet}.
             */
            Object.defineProperty(this, "signatureChainId", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            /** Function to get the next nonce for signing transactions. */
            Object.defineProperty(this, "nonceManager", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
            this.transport = args.transport;
            this.wallet = args.wallet;
            this.isTestnet = args.isTestnet ?? false;
            this.defaultVaultAddress = args.defaultVaultAddress;
            this.defaultExpiresAfter = args.defaultExpiresAfter;
            this.signatureChainId = args.signatureChainId ?? this._guessSignatureChainId;
            this.nonceManager = args.nonceManager ?? new NonceManager().getNonce;
        }
        /**
         * Approve an agent to sign on behalf of the master account.
         * @param args - The parameters for the request.
         * @param signal - An optional abort signal
         * @returns Successful response without specific data.
         * @throws {ApiRequestError} When the API returns an error response.
         *
         * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#approve-an-api-wallet
         * @example
         * ```ts
         * import * as hl from "@nktkas/hyperliquid";
         * import { privateKeyToAccount } from "viem/accounts";
         *
         * const wallet = privateKeyToAccount("0x...");
         * const transport = new hl.HttpTransport(); // or WebSocketTransport
         * const client = new hl.WalletClient({ wallet, transport });
         *
         * const result = await client.approveAgent({ agentAddress: "0x...", agentName: "agentName" });
         * ```
         */
        async approveAgent(args, signal) {
            // Construct an action
            const action = {
                ...args,
                agentName: args.agentName ?? "",
                type: "approveAgent",
                hyperliquidChain: this._getHyperliquidChain(),
                signatureChainId: await this._getSignatureChainId(),
                nonce: await this.nonceManager(),
            };
            // Sign the action
            const signature = await (0, signing_js_1.signUserSignedAction)({
                wallet: this.wallet,
                action,
                types: {
                    "HyperliquidTransaction:ApproveAgent": [
                        { name: "hyperliquidChain", type: "string" },
                        { name: "agentAddress", type: "address" },
                        { name: "agentName", type: "string" },
                        { name: "nonce", type: "uint64" },
                    ],
                },
                chainId: parseInt(action.signatureChainId, 16),
            });
            if (action.agentName === "")
                delete action.agentName;
            // Send a request
            const request = { action, signature, nonce: action.nonce };
            const response = await this.transport.request("exchange", request, signal);
            // Validate a response
            this._validateResponse(response);
            return response;
        }
        /**
         * Approve a maximum fee rate for a builder.
         * @param args - The parameters for the request.
         * @param signal - An optional abort signal.
         * @returns Successful response without specific data.
         * @throws {ApiRequestError} When the API returns an error response.
         *
         * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#approve-a-builder-fee
         * @example
         * ```ts
         * import * as hl from "@nktkas/hyperliquid";
         * import { privateKeyToAccount } from "viem/accounts";
         *
         * const wallet = privateKeyToAccount("0x...");
         * const transport = new hl.HttpTransport(); // or WebSocketTransport
         * const client = new hl.WalletClient({ wallet, transport });
         *
         * const result = await client.approveBuilderFee({ maxFeeRate: "0.01%", builder: "0x..." });
         * ```
         */
        async approveBuilderFee(args, signal) {
            // Construct an action
            const action = {
                ...args,
                type: "approveBuilderFee",
                hyperliquidChain: this._getHyperliquidChain(),
                signatureChainId: await this._getSignatureChainId(),
                nonce: await this.nonceManager(),
            };
            // Sign the action
            const signature = await (0, signing_js_1.signUserSignedAction)({
                wallet: this.wallet,
                action,
                types: {
                    "HyperliquidTransaction:ApproveBuilderFee": [
                        { name: "hyperliquidChain", type: "string" },
                        { name: "maxFeeRate", type: "string" },
                        { name: "builder", type: "address" },
                        { name: "nonce", type: "uint64" },
                    ],
                },
                chainId: parseInt(action.signatureChainId, 16),
            });
            // Send a request
            const request = { action, signature, nonce: action.nonce };
            const response = await this.transport.request("exchange", request, signal);
            // Validate a response
            this._validateResponse(response);
            return response;
        }
        /**
         * Modify multiple orders.
         * @param args - The parameters for the request.
         * @param signal - An optional abort signal.
         * @returns Successful variant of {@link OrderResponse} without error statuses.
         * @throws {ApiRequestError} When the API returns an error response.
         *
         * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#modify-multiple-orders
         * @example
         * ```ts
         * import * as hl from "@nktkas/hyperliquid";
         * import { privateKeyToAccount } from "viem/accounts";
         *
         * const wallet = privateKeyToAccount("0x...");
         * const transport = new hl.HttpTransport(); // or WebSocketTransport
         * const client = new hl.WalletClient({ wallet, transport });
         *
         * const result = await client.batchModify({
         *   modifies: [{
         *     oid: 123,
         *     order: {
         *       a: 0, // Asset index
         *       b: true, // Buy order
         *       p: "31000", // New price
         *       s: "0.2", // New size
         *       r: false, // Not reduce-only
         *       t: {
         *         limit: {
         *           tif: "Gtc", // Good-til-cancelled
         *         },
         *       },
         *       c: "0x...", // Optional: Client Order ID
         *     },
         *   }],
         * });
         * ```
         */
        async batchModify(args, signal) {
            // Destructure the parameters
            const { vaultAddress = this.defaultVaultAddress, expiresAfter = await this._getDefaultExpiresAfter(), ...actionArgs } = args;
            // Construct an action
            const nonce = await this.nonceManager();
            const action = {
                type: "batchModify",
                modifies: actionArgs.modifies.map((modify) => {
                    const sortedModify = {
                        oid: modify.oid,
                        order: {
                            a: modify.order.a,
                            b: modify.order.b,
                            p: this._formatDecimal(modify.order.p),
                            s: this._formatDecimal(modify.order.s),
                            r: modify.order.r,
                            t: "limit" in modify.order.t
                                ? {
                                    limit: {
                                        tif: modify.order.t.limit.tif,
                                    },
                                }
                                : {
                                    trigger: {
                                        isMarket: modify.order.t.trigger.isMarket,
                                        triggerPx: this._formatDecimal(modify.order.t.trigger.triggerPx),
                                        tpsl: modify.order.t.trigger.tpsl,
                                    },
                                },
                            c: modify.order.c,
                        },
                    };
                    if (sortedModify.order.c === undefined)
                        delete sortedModify.order.c;
                    return sortedModify;
                }),
            };
            // Sign the action
            const signature = await (0, signing_js_1.signL1Action)({
                wallet: this.wallet,
                action,
                nonce,
                isTestnet: this.isTestnet,
                vaultAddress,
                expiresAfter,
            });
            // Send a request
            const request = { action, signature, nonce, vaultAddress, expiresAfter };
            const response = await this.transport.request("exchange", request, signal);
            // Validate a response
            this._validateResponse(response);
            return response;
        }
        /**
         * Cancel order(s).
         * @param args - The parameters for the request.
         * @param signal - An optional abort signal.
         * @returns Successful variant of {@link CancelResponse} without error statuses.
         * @throws {ApiRequestError} When the API returns an error response.
         *
         * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#cancel-order-s
         * @example
         * ```ts
         * import * as hl from "@nktkas/hyperliquid";
         * import { privateKeyToAccount } from "viem/accounts";
         *
         * const wallet = privateKeyToAccount("0x...");
         * const transport = new hl.HttpTransport(); // or WebSocketTransport
         * const client = new hl.WalletClient({ wallet, transport });
         *
         * const result = await client.cancel({
         *   cancels: [{
         *     a: 0, // Asset index
         *     o: 123, // Order ID
         *   }],
         * });
         * ```
         */
        async cancel(args, signal) {
            // Destructure the parameters
            const { vaultAddress = this.defaultVaultAddress, expiresAfter = await this._getDefaultExpiresAfter(), ...actionArgs } = args;
            // Construct an action
            const nonce = await this.nonceManager();
            const action = {
                type: "cancel",
                cancels: actionArgs.cancels.map((cancel) => ({
                    a: cancel.a,
                    o: cancel.o,
                })),
            };
            // Sign the action
            const signature = await (0, signing_js_1.signL1Action)({
                wallet: this.wallet,
                action,
                nonce,
                isTestnet: this.isTestnet,
                vaultAddress,
                expiresAfter,
            });
            // Send a request
            const request = { action, signature, nonce, vaultAddress, expiresAfter };
            const response = await this.transport.request("exchange", request, signal);
            // Validate a response
            this._validateResponse(response);
            return response;
        }
        /**
         * Cancel order(s) by cloid.
         * @param args - The parameters for the request.
         * @param signal - An optional abort signal.
         * @returns Successful variant of {@link CancelResponse} without error statuses.
         * @throws {ApiRequestError} When the API returns an error response.
         *
         * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#cancel-order-s-by-cloid
         * @example
         * ```ts
         * import * as hl from "@nktkas/hyperliquid";
         * import { privateKeyToAccount } from "viem/accounts";
         *
         * const wallet = privateKeyToAccount("0x...");
         * const transport = new hl.HttpTransport(); // or WebSocketTransport
         * const client = new hl.WalletClient({ wallet, transport });
         *
         * const result = await client.cancelByCloid({
         *   cancels: [
         *     { asset: 0, cloid: "0x..." },
         *   ],
         * });
         * ```
         */
        async cancelByCloid(args, signal) {
            // Destructure the parameters
            const { vaultAddress = this.defaultVaultAddress, expiresAfter = await this._getDefaultExpiresAfter(), ...actionArgs } = args;
            // Construct an action
            const nonce = await this.nonceManager();
            const action = {
                type: "cancelByCloid",
                cancels: actionArgs.cancels.map((cancel) => ({
                    asset: cancel.asset,
                    cloid: cancel.cloid,
                })),
            };
            // Sign the action
            const signature = await (0, signing_js_1.signL1Action)({
                wallet: this.wallet,
                action,
                nonce,
                isTestnet: this.isTestnet,
                vaultAddress,
                expiresAfter,
            });
            // Send a request
            const request = { action, signature, nonce, vaultAddress, expiresAfter };
            const response = await this.transport.request("exchange", request, signal);
            // Validate a response
            this._validateResponse(response);
            return response;
        }
        /**
         * Transfer native token from the user's spot account into staking for delegating to validators.
         * @param args - The parameters for the request.
         * @param signal - An optional abort signal.
         * @returns Successful response without specific data.
         * @throws {ApiRequestError} When the API returns an error response.
         *
         * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#deposit-into-staking
         * @example
         * ```ts
         * import * as hl from "@nktkas/hyperliquid";
         * import { privateKeyToAccount } from "viem/accounts";
         *
         * const wallet = privateKeyToAccount("0x...");
         * const transport = new hl.HttpTransport(); // or WebSocketTransport
         * const client = new hl.WalletClient({ wallet, transport });
         *
         * const result = await client.cDeposit({ wei: 1 * 1e8 });
         * ```
         */
        async cDeposit(args, signal) {
            // Construct an action
            const action = {
                ...args,
                type: "cDeposit",
                hyperliquidChain: this._getHyperliquidChain(),
                signatureChainId: await this._getSignatureChainId(),
                nonce: await this.nonceManager(),
            };
            // Sign the action
            const signature = await (0, signing_js_1.signUserSignedAction)({
                wallet: this.wallet,
                action,
                types: {
                    "HyperliquidTransaction:CDeposit": [
                        { name: "hyperliquidChain", type: "string" },
                        { name: "wei", type: "uint64" },
                        { name: "nonce", type: "uint64" },
                    ],
                },
                chainId: parseInt(action.signatureChainId, 16),
            });
            // Send a request
            const request = { action, signature, nonce: action.nonce };
            const response = await this.transport.request("exchange", request, signal);
            // Validate a response
            this._validateResponse(response);
            return response;
        }
        /**
         * Claim rewards from referral program.
         * @param args - The parameters for the request.
         * @param signal - An optional abort signal.
         * @returns Successful response without specific data.
         * @throws {ApiRequestError} When the API returns an error response.
         *
         * @see null - no documentation
         * @example
         * ```ts
         * import * as hl from "@nktkas/hyperliquid";
         * import { privateKeyToAccount } from "viem/accounts";
         *
         * const wallet = privateKeyToAccount("0x...");
         * const transport = new hl.HttpTransport(); // or WebSocketTransport
         * const client = new hl.WalletClient({ wallet, transport });
         *
         * const result = await client.claimRewards();
         * ```
         */
        async claimRewards(signal) {
            // Construct an action
            const nonce = await this.nonceManager();
            const action = { type: "claimRewards" };
            // Sign the action
            const signature = await (0, signing_js_1.signL1Action)({
                wallet: this.wallet,
                action,
                nonce,
                isTestnet: this.isTestnet,
            });
            // Send a request
            const request = { action, signature, nonce };
            const response = await this.transport.request("exchange", request, signal);
            // Validate a response
            this._validateResponse(response);
            return response;
        }
        /**
         * Convert a single-signature account to a multi-signature account.
         * @param args - The parameters for the request.
         * @param signal - An optional abort signal.
         * @returns Successful response without specific data.
         * @throws {ApiRequestError} When the API returns an error response.
         *
         * @see https://hyperliquid.gitbook.io/hyperliquid-docs/hypercore/multi-sig
         * @example
         * ```ts
         * import * as hl from "@nktkas/hyperliquid";
         * import { privateKeyToAccount } from "viem/accounts";
         *
         * const wallet = privateKeyToAccount("0x...");
         * const transport = new hl.HttpTransport(); // or WebSocketTransport
         * const client = new hl.WalletClient({ wallet, transport });
         *
         * const result = await client.convertToMultiSigUser({
         *   authorizedUsers: ["0x...", "0x..."],
         *   threshold: 2,
         * });
         * ```
         */
        async convertToMultiSigUser(args, signal) {
            // Construct an action
            const action = {
                type: "convertToMultiSigUser",
                hyperliquidChain: this._getHyperliquidChain(),
                signatureChainId: await this._getSignatureChainId(),
                signers: JSON.stringify(args),
                nonce: await this.nonceManager(),
            };
            // Sign the action
            const signature = await (0, signing_js_1.signUserSignedAction)({
                wallet: this.wallet,
                action,
                types: {
                    "HyperliquidTransaction:ConvertToMultiSigUser": [
                        { name: "hyperliquidChain", type: "string" },
                        { name: "signers", type: "string" },
                        { name: "nonce", type: "uint64" },
                    ],
                },
                chainId: parseInt(action.signatureChainId, 16),
            });
            // Send a request
            const request = { action, signature, nonce: action.nonce };
            const response = await this.transport.request("exchange", request, signal);
            // Validate a response
            this._validateResponse(response);
            return response;
        }
        /**
         * Create a sub-account.
         * @param args - The parameters for the request.
         * @param signal - An optional abort signal.
         * @returns Response for creating a sub-account.
         * @throws {ApiRequestError} When the API returns an error response.
         *
         * @see null - no documentation
         * @example
         * ```ts
         * import * as hl from "@nktkas/hyperliquid";
         * import { privateKeyToAccount } from "viem/accounts";
         *
         * const wallet = privateKeyToAccount("0x...");
         * const transport = new hl.HttpTransport(); // or WebSocketTransport
         * const client = new hl.WalletClient({ wallet, transport });
         *
         * const result = await client.createSubAccount({ name: "subAccountName" });
         * ```
         */
        async createSubAccount(args, signal) {
            // Construct an action
            const nonce = await this.nonceManager();
            const action = {
                type: "createSubAccount",
                name: args.name,
            };
            // Sign the action
            const signature = await (0, signing_js_1.signL1Action)({
                wallet: this.wallet,
                action,
                nonce,
                isTestnet: this.isTestnet,
            });
            // Send a request
            const request = { action, signature, nonce };
            const response = await this.transport.request("exchange", request, signal);
            // Validate a response
            this._validateResponse(response);
            return response;
        }
        /**
         * Create a vault.
         * @param args - The parameters for the request.
         * @param signal - An optional abort signal.
         * @returns Response for creating a vault.
         * @throws {ApiRequestError} When the API returns an error response.
         *
         * @see null - no documentation
         * @example
         * ```ts
         * import * as hl from "@nktkas/hyperliquid";
         * import { privateKeyToAccount } from "viem/accounts";
         *
         * const wallet = privateKeyToAccount("0x...");
         * const transport = new hl.HttpTransport(); // or WebSocketTransport
         * const client = new hl.WalletClient({ wallet, transport });
         *
         * const result = await client.createVault({
         *   name: "VaultName",
         *   description: "This is an example of a vault description",
         *   initialUsd: 100 * 1e6,
         * });
         * ```
         */
        async createVault(args, signal) {
            // Construct an action
            const nonce = await this.nonceManager();
            const action = {
                type: "createVault",
                name: args.name,
                description: args.description,
                initialUsd: args.initialUsd,
                nonce,
            };
            // Sign the action
            const signature = await (0, signing_js_1.signL1Action)({
                wallet: this.wallet,
                action,
                nonce,
                isTestnet: this.isTestnet,
            });
            // Send a request
            const request = { action, signature, nonce };
            const response = await this.transport.request("exchange", request, signal);
            // Validate a response
            this._validateResponse(response);
            return response;
        }
        async cSignerAction(args, signal) {
            // Destructure the parameters
            const { expiresAfter = await this._getDefaultExpiresAfter(), ...actionArgs } = args;
            // Construct an action
            const nonce = await this.nonceManager();
            const action = {
                type: "CSignerAction",
                ...actionArgs,
            };
            // Sign the action
            const signature = await (0, signing_js_1.signL1Action)({
                wallet: this.wallet,
                action,
                nonce,
                isTestnet: this.isTestnet,
                expiresAfter,
            });
            // Send a request
            const request = { action, signature, nonce, expiresAfter };
            const response = await this.transport.request("exchange", request, signal);
            // Validate a response
            this._validateResponse(response);
            return response;
        }
        async cValidatorAction(args, signal) {
            // Destructure the parameters
            const { expiresAfter = await this._getDefaultExpiresAfter(), ...actionArgs } = args;
            // Construct an action
            const nonce = await this.nonceManager();
            let action;
            if ("changeProfile" in actionArgs) {
                action = {
                    type: "CValidatorAction",
                    changeProfile: {
                        node_ip: actionArgs.changeProfile.node_ip ?? null,
                        name: actionArgs.changeProfile.name ?? null,
                        description: actionArgs.changeProfile.description ?? null,
                        unjailed: actionArgs.changeProfile.unjailed,
                        disable_delegations: actionArgs.changeProfile.disable_delegations ?? null,
                        commission_bps: actionArgs.changeProfile.commission_bps ?? null,
                        signer: actionArgs.changeProfile.signer?.toLowerCase() ?? null,
                    },
                };
            }
            else if ("register" in actionArgs) {
                action = {
                    type: "CValidatorAction",
                    register: {
                        profile: {
                            node_ip: { Ip: actionArgs.register.profile.node_ip.Ip },
                            name: actionArgs.register.profile.name,
                            description: actionArgs.register.profile.description,
                            delegations_disabled: actionArgs.register.profile.delegations_disabled,
                            commission_bps: actionArgs.register.profile.commission_bps,
                            signer: actionArgs.register.profile.signer?.toLowerCase(),
                        },
                        unjailed: actionArgs.register.unjailed,
                        initial_wei: actionArgs.register.initial_wei,
                    },
                };
            }
            else {
                action = {
                    type: "CValidatorAction",
                    unregister: actionArgs.unregister,
                };
            }
            // Sign the action
            const signature = await (0, signing_js_1.signL1Action)({
                wallet: this.wallet,
                action,
                nonce,
                isTestnet: this.isTestnet,
                expiresAfter,
            });
            // Send a request
            const request = { action, signature, nonce, expiresAfter };
            const response = await this.transport.request("exchange", request, signal);
            // Validate a response
            this._validateResponse(response);
            return response;
        }
        /**
         * Transfer native token from staking into the user's spot account.
         * @param args - The parameters for the request.
         * @param signal - An optional abort signal.
         * @returns Successful response without specific data.
         * @throws {ApiRequestError} When the API returns an error response.
         *
         * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#withdraw-from-staking
         * @example
         * ```ts
         * import * as hl from "@nktkas/hyperliquid";
         * import { privateKeyToAccount } from "viem/accounts";
         *
         * const wallet = privateKeyToAccount("0x...");
         * const transport = new hl.HttpTransport(); // or WebSocketTransport
         * const client = new hl.WalletClient({ wallet, transport });
         *
         * const result = await client.cWithdraw({ wei: 1 * 1e8 });
         * ```
         */
        async cWithdraw(args, signal) {
            // Construct an action
            const action = {
                ...args,
                type: "cWithdraw",
                hyperliquidChain: this._getHyperliquidChain(),
                signatureChainId: await this._getSignatureChainId(),
                nonce: await this.nonceManager(),
            };
            // Sign the action
            const signature = await (0, signing_js_1.signUserSignedAction)({
                wallet: this.wallet,
                action,
                types: {
                    "HyperliquidTransaction:CWithdraw": [
                        { name: "hyperliquidChain", type: "string" },
                        { name: "wei", type: "uint64" },
                        { name: "nonce", type: "uint64" },
                    ],
                },
                chainId: parseInt(action.signatureChainId, 16),
            });
            // Send a request
            const request = { action, signature, nonce: action.nonce };
            const response = await this.transport.request("exchange", request, signal);
            // Validate a response
            this._validateResponse(response);
            return response;
        }
        /**
         * Configure block type for EVM transactions.
         * @param args - The parameters for the request.
         * @param signal - An optional abort signal.
         * @returns Response for creating a sub-account.
         * @throws {ApiRequestError} When the API returns an error response.
         *
         * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/evm/dual-block-architecture
         * @example
         * ```ts
         * import * as hl from "@nktkas/hyperliquid";
         * import { privateKeyToAccount } from "viem/accounts";
         *
         * const wallet = privateKeyToAccount("0x...");
         * const transport = new hl.HttpTransport(); // or WebSocketTransport
         * const client = new hl.WalletClient({ wallet, transport });
         *
         * const result = await client.evmUserModify({ usingBigBlocks: true });
         * ```
         */
        async evmUserModify(args, signal) {
            // Construct an action
            const nonce = await this.nonceManager();
            const action = {
                type: "evmUserModify",
                usingBigBlocks: args.usingBigBlocks,
            };
            // Sign the action
            const signature = await (0, signing_js_1.signL1Action)({
                wallet: this.wallet,
                action,
                nonce,
                isTestnet: this.isTestnet,
            });
            // Send a request
            const request = { action, signature, nonce };
            const response = await this.transport.request("exchange", request, signal);
            // Validate a response
            this._validateResponse(response);
            return response;
        }
        /**
         * Modify an order.
         * @param args - The parameters for the request.
         * @param signal - An optional abort signal.
         * @returns Successful response without specific data.
         * @throws {ApiRequestError} When the API returns an error response.
         *
         * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#modify-an-order
         * @example
         * ```ts
         * import * as hl from "@nktkas/hyperliquid";
         * import { privateKeyToAccount } from "viem/accounts";
         *
         * const wallet = privateKeyToAccount("0x...");
         * const transport = new hl.HttpTransport(); // or WebSocketTransport
         * const client = new hl.WalletClient({ wallet, transport });
         *
         * const result = await client.modify({
         *   oid: 123,
         *   order: {
         *     a: 0, // Asset index
         *     b: true, // Buy order
         *     p: "31000", // New price
         *     s: "0.2", // New size
         *     r: false, // Not reduce-only
         *     t: {
         *       limit: {
         *         tif: "Gtc", // Good-til-cancelled
         *       },
         *     },
         *     c: "0x...", // Optional: Client Order ID
         *   },
         * });
         * ```
         */
        async modify(args, signal) {
            // Destructure the parameters
            const { vaultAddress = this.defaultVaultAddress, expiresAfter = await this._getDefaultExpiresAfter(), ...actionArgs } = args;
            // Construct an action
            const nonce = await this.nonceManager();
            const action = {
                type: "modify",
                oid: actionArgs.oid,
                order: {
                    a: actionArgs.order.a,
                    b: actionArgs.order.b,
                    p: this._formatDecimal(actionArgs.order.p),
                    s: this._formatDecimal(actionArgs.order.s),
                    r: actionArgs.order.r,
                    t: "limit" in actionArgs.order.t
                        ? {
                            limit: {
                                tif: actionArgs.order.t.limit.tif,
                            },
                        }
                        : {
                            trigger: {
                                isMarket: actionArgs.order.t.trigger.isMarket,
                                triggerPx: this._formatDecimal(actionArgs.order.t.trigger.triggerPx),
                                tpsl: actionArgs.order.t.trigger.tpsl,
                            },
                        },
                    c: actionArgs.order.c,
                },
            };
            if (action.order.c === undefined)
                delete action.order.c;
            // Sign the action
            const signature = await (0, signing_js_1.signL1Action)({
                wallet: this.wallet,
                action,
                nonce,
                isTestnet: this.isTestnet,
                vaultAddress,
                expiresAfter,
            });
            // Send a request
            const request = { action, signature, nonce, vaultAddress, expiresAfter };
            const response = await this.transport.request("exchange", request, signal);
            // Validate a response
            this._validateResponse(response);
            return response;
        }
        /**
         * A multi-signature request.
         * @param args - The parameters for the request.
         * @param signal - An optional abort signal.
         * @returns Successful response without specific data.
         * @throws {ApiRequestError} When the API returns an error response.
         *
         * @see https://hyperliquid.gitbook.io/hyperliquid-docs/hypercore/multi-sig
         * @example
         * ```ts
         * import * as hl from "@nktkas/hyperliquid";
         * import { privateKeyToAccount } from "viem/accounts";
         *
         * const wallet = privateKeyToAccount("0x...");
         * const transport = new hl.HttpTransport(); // or WebSocketTransport
         * const client = new hl.WalletClient({ wallet, transport });
         *
         * const multiSigUser = "0x..."; // Multi-sig user address
         *
         * const nonce = Date.now();
         * const action = { type: "scheduleCancel", time: Date.now() + 10000 };
         *
         * const signature = await hl.signL1Action({
         *   wallet,
         *   action: [multiSigUser.toLowerCase(), signer1.address.toLowerCase(), action],
         *   nonce,
         *   isTestnet: true,
         * });
         *
         * const result = await client.multiSig({
         *   signatures: [signature],
         *   payload: {
         *     multiSigUser,
         *     outerSigner: wallet.address,
         *     action,
         *   },
         *   nonce,
         * });
         * ```
         * @unstable May not behave as expected and the interface may change in the future.
         */
        async multiSig(args, signal) {
            // Destructure the parameters
            const { vaultAddress = this.defaultVaultAddress, expiresAfter = await this._getDefaultExpiresAfter(), nonce, ...actionArgs } = args;
            // Construct an action
            const hyperliquidChain = this._getHyperliquidChain();
            const action = {
                type: "multiSig",
                signatureChainId: await this._getSignatureChainId(),
                signatures: actionArgs.signatures.map((signature) => ({
                    r: signature.r.replace(/^0x0+/, "0x").toLowerCase(),
                    s: signature.s.replace(/^0x0+/, "0x").toLowerCase(),
                    v: signature.v,
                })),
                payload: {
                    multiSigUser: actionArgs.payload.multiSigUser.toLowerCase(),
                    outerSigner: actionArgs.payload.outerSigner.toLowerCase(),
                    action: actionArgs.payload.action,
                },
            };
            // Sign the action
            const actionForMultiSig = structuredClone(action);
            delete actionForMultiSig.type;
            const signature = await (0, signing_js_1.signMultiSigAction)({
                wallet: this.wallet,
                action: actionForMultiSig,
                nonce,
                vaultAddress,
                expiresAfter,
                hyperliquidChain,
                signatureChainId: action.signatureChainId,
            });
            // Send a request
            const request = { action, signature, nonce, vaultAddress, expiresAfter };
            const response = await this.transport.request("exchange", request, signal);
            // Validate a response
            this._validateResponse(response);
            return response;
        }
        /**
         * Place an order(s).
         * @param args - The parameters for the request.
         * @param signal - An optional abort signal.
         * @returns Successful variant of {@link OrderResponse} without error statuses.
         * @throws {ApiRequestError} When the API returns an error response.
         *
         * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#place-an-order
         * @example
         * ```ts
         * import * as hl from "@nktkas/hyperliquid";
         * import { privateKeyToAccount } from "viem/accounts";
         *
         * const wallet = privateKeyToAccount("0x...");
         * const transport = new hl.HttpTransport(); // or WebSocketTransport
         * const client = new hl.WalletClient({ wallet, transport });
         *
         * const result = await client.order({
         *   orders: [{
         *     a: 0, // Asset index
         *     b: true, // Buy order
         *     p: "30000", // Price
         *     s: "0.1", // Size
         *     r: false, // Not reduce-only
         *     t: {
         *       limit: {
         *         tif: "Gtc", // Good-til-cancelled
         *       },
         *     },
         *     c: "0x...", // Optional: Client Order ID
         *   }],
         *   grouping: "na", // No grouping
         * });
         * ```
         */
        async order(args, signal) {
            // Destructure the parameters
            const { vaultAddress = this.defaultVaultAddress, expiresAfter = await this._getDefaultExpiresAfter(), ...actionArgs } = args;
            // Construct an action
            const nonce = await this.nonceManager();
            const action = {
                type: "order",
                orders: actionArgs.orders.map((order) => {
                    const sortedOrder = {
                        a: order.a,
                        b: order.b,
                        p: this._formatDecimal(order.p),
                        s: this._formatDecimal(order.s),
                        r: order.r,
                        t: "limit" in order.t
                            ? {
                                limit: {
                                    tif: order.t.limit.tif,
                                },
                            }
                            : {
                                trigger: {
                                    isMarket: order.t.trigger.isMarket,
                                    triggerPx: this._formatDecimal(order.t.trigger.triggerPx),
                                    tpsl: order.t.trigger.tpsl,
                                },
                            },
                        c: order.c,
                    };
                    if (order.c === undefined)
                        delete sortedOrder.c;
                    return sortedOrder;
                }),
                grouping: actionArgs.grouping,
                builder: actionArgs.builder
                    ? {
                        b: actionArgs.builder.b.toLowerCase(),
                        f: actionArgs.builder.f,
                    }
                    : actionArgs.builder,
            };
            if (action.builder === undefined)
                delete action.builder;
            // Sign the action
            const signature = await (0, signing_js_1.signL1Action)({
                wallet: this.wallet,
                action,
                nonce,
                isTestnet: this.isTestnet,
                vaultAddress,
                expiresAfter,
            });
            // Send a request
            const request = { action, signature, nonce, vaultAddress, expiresAfter };
            const response = await this.transport.request("exchange", request, signal);
            // Validate a response
            this._validateResponse(response);
            return response;
        }
        async perpDeploy(args, signal) {
            // Construct an action
            const nonce = await this.nonceManager();
            let action;
            if ("registerAsset" in args) {
                action = {
                    type: "perpDeploy",
                    registerAsset: {
                        maxGas: args.registerAsset.maxGas ?? null,
                        assetRequest: {
                            coin: args.registerAsset.assetRequest.coin,
                            szDecimals: args.registerAsset.assetRequest.szDecimals,
                            oraclePx: args.registerAsset.assetRequest.oraclePx,
                            marginTableId: args.registerAsset.assetRequest.marginTableId,
                            onlyIsolated: args.registerAsset.assetRequest.onlyIsolated,
                        },
                        dex: args.registerAsset.dex,
                        schema: args.registerAsset.schema
                            ? {
                                fullName: args.registerAsset.schema.fullName,
                                collateralToken: args.registerAsset.schema.collateralToken,
                                oracleUpdater: args.registerAsset.schema.oracleUpdater?.toLowerCase() ??
                                    null,
                            }
                            : null,
                    },
                };
            }
            else {
                action = {
                    type: "perpDeploy",
                    setOracle: {
                        dex: args.setOracle.dex,
                        oraclePxs: args.setOracle.oraclePxs,
                        markPxs: args.setOracle.markPxs,
                    },
                };
            }
            // Sign the action
            const signature = await (0, signing_js_1.signL1Action)({
                wallet: this.wallet,
                action,
                nonce,
                isTestnet: this.isTestnet,
            });
            // Send a request
            const request = { action, signature, nonce };
            const response = await this.transport.request("exchange", request, signal);
            // Validate a response
            this._validateResponse(response);
            return response;
        }
        /**
         * Transfer funds between Spot account and Perp dex account.
         * @param args - The parameters for the request.
         * @param signal - An optional abort signal.
         * @returns Successful response without specific data.
         * @throws {ApiRequestError} When the API returns an error response.
         *
         * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#transfer-from-spot-account-to-perp-account-and-vice-versa
         * @example
         * ```ts
         * import * as hl from "@nktkas/hyperliquid";
         * import { privateKeyToAccount } from "viem/accounts";
         *
         * const wallet = privateKeyToAccount("0x...");
         * const transport = new hl.HttpTransport(); // or WebSocketTransport
         * const client = new hl.WalletClient({ wallet, transport });
         *
         * const result = await client.perpDexClassTransfer({
         *   dex: "test",
         *   token: "USDC",
         *   amount: "1",
         *   toPerp: true,
         * });
         * ```
         */
        async perpDexClassTransfer(args, signal) {
            // Construct an action
            const action = {
                ...args,
                type: "PerpDexClassTransfer",
                hyperliquidChain: this._getHyperliquidChain(),
                signatureChainId: await this._getSignatureChainId(),
                nonce: await this.nonceManager(),
            };
            // Sign the action
            const signature = await (0, signing_js_1.signUserSignedAction)({
                wallet: this.wallet,
                action,
                types: {
                    "HyperliquidTransaction:PerpDexClassTransfer": [
                        { name: "hyperliquidChain", type: "string" },
                        { name: "dex", type: "string" },
                        { name: "token", type: "string" },
                        { name: "amount", type: "string" },
                        { name: "toPerp", type: "bool" },
                        { name: "nonce", type: "uint64" },
                    ],
                },
                chainId: parseInt(action.signatureChainId, 16),
            });
            // Send a request
            const request = { action, signature, nonce: action.nonce };
            const response = await this.transport.request("exchange", request, signal);
            // Validate a response
            this._validateResponse(response);
            return response;
        }
        /**
         * Create a referral code.
         * @param args - The parameters for the request.
         * @param signal - An optional abort signal.
         * @returns Successful response without specific data.
         * @throws {ApiRequestError} When the API returns an error response.
         *
         * @see null - no documentation
         * @example
         * ```ts
         * import * as hl from "@nktkas/hyperliquid";
         * import { privateKeyToAccount } from "viem/accounts";
         *
         * const wallet = privateKeyToAccount("0x...");
         * const transport = new hl.HttpTransport(); // or WebSocketTransport
         * const client = new hl.WalletClient({ wallet, transport });
         *
         * const result = await client.registerReferrer({ code: "TEST" });
         * ```
         */
        async registerReferrer(args, signal) {
            // Construct an action
            const nonce = await this.nonceManager();
            const action = {
                type: "registerReferrer",
                code: args.code,
            };
            // Sign the action
            const signature = await (0, signing_js_1.signL1Action)({
                wallet: this.wallet,
                action,
                nonce,
                isTestnet: this.isTestnet,
            });
            // Send a request
            const request = { action, signature, nonce };
            const response = await this.transport.request("exchange", request, signal);
            // Validate a response
            this._validateResponse(response);
            return response;
        }
        /**
         * Reserve additional rate-limited actions for a fee.
         * @param args - The parameters for the request.
         * @param signal - An optional abort signal.
         * @returns Successful response without specific data.
         * @throws {ApiRequestError} When the API returns an error response.
         *
         * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#reserve-additional-actions
         * @example
         * ```ts
         * import * as hl from "@nktkas/hyperliquid";
         * import { privateKeyToAccount } from "viem/accounts";
         *
         * const wallet = privateKeyToAccount("0x...");
         * const transport = new hl.HttpTransport(); // or WebSocketTransport
         * const client = new hl.WalletClient({ wallet, transport });
         *
         * const result = await client.reserveRequestWeight({ weight: 10 });
         * ```
         */
        async reserveRequestWeight(args, signal) {
            // Destructure the parameters
            const { expiresAfter = await this._getDefaultExpiresAfter(), ...actionArgs } = args;
            // Construct an action
            const nonce = await this.nonceManager();
            const action = {
                type: "reserveRequestWeight",
                weight: actionArgs.weight,
            };
            // Sign the action
            const signature = await (0, signing_js_1.signL1Action)({
                wallet: this.wallet,
                action,
                nonce,
                isTestnet: this.isTestnet,
                expiresAfter,
            });
            // Send a request
            const request = { action, signature, nonce, expiresAfter };
            const response = await this.transport.request("exchange", request, signal);
            // Validate a response
            this._validateResponse(response);
            return response;
        }
        async scheduleCancel(args_or_signal, maybeSignal) {
            const args = args_or_signal instanceof AbortSignal ? {} : args_or_signal ?? {};
            const signal = args_or_signal instanceof AbortSignal ? args_or_signal : maybeSignal;
            // Destructure the parameters
            const { vaultAddress = this.defaultVaultAddress, expiresAfter = await this._getDefaultExpiresAfter(), ...actionArgs } = args;
            // Construct an action
            const nonce = await this.nonceManager();
            const action = {
                type: "scheduleCancel",
                time: actionArgs.time,
            };
            if (action.time === undefined)
                delete action.time;
            // Sign the action
            const signature = await (0, signing_js_1.signL1Action)({
                wallet: this.wallet,
                action,
                nonce,
                isTestnet: this.isTestnet,
                vaultAddress,
                expiresAfter,
            });
            // Send a request
            const request = { action, signature, nonce, vaultAddress, expiresAfter };
            const response = await this.transport.request("exchange", request, signal);
            // Validate a response
            this._validateResponse(response);
            return response;
        }
        /**
         * Set the display name in the leaderboard.
         * @param args - The parameters for the request.
         * @param signal - An optional abort signal.
         * @returns Successful response without specific data.
         * @throws {ApiRequestError} When the API returns an error response.
         *
         * @see null - no documentation
         * @example
         * ```ts
         * import * as hl from "@nktkas/hyperliquid";
         * import { privateKeyToAccount } from "viem/accounts";
         *
         * const wallet = privateKeyToAccount("0x...");
         * const transport = new hl.HttpTransport(); // or WebSocketTransport
         * const client = new hl.WalletClient({ wallet, transport });
         *
         * const result = await client.setDisplayName({ displayName: "My Name" });
         * ```
         */
        async setDisplayName(args, signal) {
            // Construct an action
            const nonce = await this.nonceManager();
            const action = {
                type: "setDisplayName",
                displayName: args.displayName,
            };
            // Sign the action
            const signature = await (0, signing_js_1.signL1Action)({
                wallet: this.wallet,
                action,
                nonce,
                isTestnet: this.isTestnet,
            });
            // Send a request
            const request = { action, signature, nonce };
            const response = await this.transport.request("exchange", request, signal);
            // Validate a response
            this._validateResponse(response);
            return response;
        }
        /**
         * Set a referral code.
         * @param args - The parameters for the request.
         * @param signal - An optional abort signal.
         * @returns Successful response without specific data.
         * @throws {ApiRequestError} When the API returns an error response.
         *
         * @see null - no documentation
         * @example
         * ```ts
         * import * as hl from "@nktkas/hyperliquid";
         * import { privateKeyToAccount } from "viem/accounts";
         *
         * const wallet = privateKeyToAccount("0x...");
         * const transport = new hl.HttpTransport(); // or WebSocketTransport
         * const client = new hl.WalletClient({ wallet, transport });
         *
         * const result = await client.setReferrer({ code: "TEST" });
         * ```
         */
        async setReferrer(args, signal) {
            // Construct an action
            const nonce = await this.nonceManager();
            const action = {
                type: "setReferrer",
                code: args.code,
            };
            // Sign the action
            const signature = await (0, signing_js_1.signL1Action)({
                wallet: this.wallet,
                action,
                nonce,
                isTestnet: this.isTestnet,
            });
            // Send a request
            const request = { action, signature, nonce };
            const response = await this.transport.request("exchange", request, signal);
            // Validate a response
            this._validateResponse(response);
            return response;
        }
        async spotDeploy(args, signal) {
            // Construct an action
            const nonce = await this.nonceManager();
            let action;
            if ("registerToken2" in args) {
                action = {
                    type: "spotDeploy",
                    registerToken2: {
                        spec: {
                            name: args.registerToken2.spec.name,
                            szDecimals: args.registerToken2.spec.szDecimals,
                            weiDecimals: args.registerToken2.spec.weiDecimals,
                        },
                        maxGas: args.registerToken2.maxGas,
                        fullName: args.registerToken2.fullName,
                    },
                };
                if (action.registerToken2.fullName === undefined) {
                    delete action.registerToken2.fullName;
                }
            }
            else if ("userGenesis" in args) {
                action = {
                    type: "spotDeploy",
                    userGenesis: {
                        token: args.userGenesis.token,
                        userAndWei: args.userGenesis.userAndWei,
                        existingTokenAndWei: args.userGenesis.existingTokenAndWei,
                        blacklistUsers: args.userGenesis.blacklistUsers,
                    },
                };
                if (action.userGenesis.blacklistUsers === undefined) {
                    delete action.userGenesis.blacklistUsers;
                }
            }
            else if ("genesis" in args) {
                action = {
                    type: "spotDeploy",
                    genesis: {
                        token: args.genesis.token,
                        maxSupply: args.genesis.maxSupply,
                        noHyperliquidity: args.genesis.noHyperliquidity,
                    },
                };
                if (action.genesis.noHyperliquidity === undefined) {
                    delete action.genesis.noHyperliquidity;
                }
            }
            else if ("registerSpot" in args) {
                action = {
                    type: "spotDeploy",
                    registerSpot: {
                        tokens: args.registerSpot.tokens,
                    },
                };
            }
            else if ("registerHyperliquidity" in args) {
                action = {
                    type: "spotDeploy",
                    registerHyperliquidity: {
                        spot: args.registerHyperliquidity.spot,
                        startPx: args.registerHyperliquidity.startPx,
                        orderSz: args.registerHyperliquidity.orderSz,
                        nOrders: args.registerHyperliquidity.nOrders,
                        nSeededLevels: args.registerHyperliquidity.nSeededLevels,
                    },
                };
                if (action.registerHyperliquidity.nSeededLevels === undefined) {
                    delete action.registerHyperliquidity.nSeededLevels;
                }
            }
            else {
                action = {
                    type: "spotDeploy",
                    setDeployerTradingFeeShare: {
                        token: args.setDeployerTradingFeeShare.token,
                        share: args.setDeployerTradingFeeShare.share,
                    },
                };
            }
            // Sign the action
            const signature = await (0, signing_js_1.signL1Action)({
                wallet: this.wallet,
                action,
                nonce,
                isTestnet: this.isTestnet,
            });
            // Send a request
            const request = { action, signature, nonce };
            const response = await this.transport.request("exchange", request, signal);
            // Validate a response
            this._validateResponse(response);
            return response;
        }
        /**
         * Send spot assets to another address.
         * @param args - The parameters for the request.
         * @param signal - An optional abort signal.
         * @returns Successful response without specific data.
         * @throws {ApiRequestError} When the API returns an error response.
         *
         * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#core-spot-transfer
         * @example
         * ```ts
         * import * as hl from "@nktkas/hyperliquid";
         * import { privateKeyToAccount } from "viem/accounts";
         *
         * const wallet = privateKeyToAccount("0x...");
         * const transport = new hl.HttpTransport(); // or WebSocketTransport
         * const client = new hl.WalletClient({ wallet, transport });
         *
         * const result = await client.spotSend({
         *   destination: "0x...",
         *   token: "USDC:0xeb62eee3685fc4c43992febcd9e75443",
         *   amount: "1",
         * });
         * ```
         */
        async spotSend(args, signal) {
            // Construct an action
            const action = {
                ...args,
                type: "spotSend",
                hyperliquidChain: this._getHyperliquidChain(),
                signatureChainId: await this._getSignatureChainId(),
                time: await this.nonceManager(),
            };
            // Sign the action
            const signature = await (0, signing_js_1.signUserSignedAction)({
                wallet: this.wallet,
                action,
                types: {
                    "HyperliquidTransaction:SpotSend": [
                        { name: "hyperliquidChain", type: "string" },
                        { name: "destination", type: "string" },
                        { name: "token", type: "string" },
                        { name: "amount", type: "string" },
                        { name: "time", type: "uint64" },
                    ],
                },
                chainId: parseInt(action.signatureChainId, 16),
            });
            // Send a request
            const request = { action, signature, nonce: action.time };
            const response = await this.transport.request("exchange", request, signal);
            // Validate a response
            this._validateResponse(response);
            return response;
        }
        /**
         * Opt Out of Spot Dusting.
         * @param args - The parameters for the request.
         * @param signal - An optional abort signal.
         * @returns Successful response without specific data.
         * @throws {ApiRequestError} When the API returns an error response.
         *
         * @see null - no documentation
         * @example
         * ```ts
         * import * as hl from "@nktkas/hyperliquid";
         * import { privateKeyToAccount } from "viem/accounts";
         *
         * const wallet = privateKeyToAccount("0x...");
         * const transport = new hl.HttpTransport(); // or WebSocketTransport
         * const client = new hl.WalletClient({ wallet, transport });
         *
         * const result = await client.spotUser({ toggleSpotDusting: { optOut: false } });
         * ```
         */
        async spotUser(args, signal) {
            // Construct an action
            const nonce = await this.nonceManager();
            const action = {
                type: "spotUser",
                toggleSpotDusting: {
                    optOut: args.toggleSpotDusting.optOut,
                },
            };
            // Sign the action
            const signature = await (0, signing_js_1.signL1Action)({
                wallet: this.wallet,
                action,
                nonce,
                isTestnet: this.isTestnet,
            });
            // Send a request
            const request = { action, signature, nonce };
            const response = await this.transport.request("exchange", request, signal);
            // Validate a response
            this._validateResponse(response);
            return response;
        }
        /**
         * Transfer between sub-accounts (spot).
         * @param args - The parameters for the request.
         * @param signal - An optional abort signal.
         * @returns Successful response without specific data.
         * @throws {ApiRequestError} When the API returns an error response.
         *
         * @see null - no documentation
         * @example
         * ```ts
         * import * as hl from "@nktkas/hyperliquid";
         * import { privateKeyToAccount } from "viem/accounts";
         *
         * const wallet = privateKeyToAccount("0x...");
         * const transport = new hl.HttpTransport(); // or WebSocketTransport
         * const client = new hl.WalletClient({ wallet, transport });
         *
         * const result = await client.subAccountSpotTransfer({
         *   subAccountUser: "0x...",
         *   isDeposit: true,
         *   token: "USDC:0xeb62eee3685fc4c43992febcd9e75443",
         *   amount: "1",
         * });
         * ```
         */
        async subAccountSpotTransfer(args, signal) {
            // Construct an action
            const nonce = await this.nonceManager();
            const action = {
                type: "subAccountSpotTransfer",
                subAccountUser: args.subAccountUser,
                isDeposit: args.isDeposit,
                token: args.token,
                amount: args.amount,
            };
            // Sign the action
            const signature = await (0, signing_js_1.signL1Action)({
                wallet: this.wallet,
                action,
                nonce,
                isTestnet: this.isTestnet,
            });
            // Send a request
            const request = { action, signature, nonce };
            const response = await this.transport.request("exchange", request, signal);
            // Validate a response
            this._validateResponse(response);
            return response;
        }
        /**
         * Transfer between sub-accounts (perpetual).
         * @param args - The parameters for the request.
         * @param signal - An optional abort signal.
         * @returns Successful response without specific data.
         * @throws {ApiRequestError} When the API returns an error response.
         *
         * @see null - no documentation
         * @example
         * ```ts
         * import * as hl from "@nktkas/hyperliquid";
         * import { privateKeyToAccount } from "viem/accounts";
         *
         * const wallet = privateKeyToAccount("0x...");
         * const transport = new hl.HttpTransport(); // or WebSocketTransport
         * const client = new hl.WalletClient({ wallet, transport });
         *
         * const result = await client.subAccountTransfer({
         *   subAccountUser: "0x...",
         *   isDeposit: true,
         *   usd: 1 * 1e6,
         * });
         * ```
         */
        async subAccountTransfer(args, signal) {
            // Construct an action
            const nonce = await this.nonceManager();
            const action = {
                type: "subAccountTransfer",
                subAccountUser: args.subAccountUser,
                isDeposit: args.isDeposit,
                usd: args.usd,
            };
            // Sign the action
            const signature = await (0, signing_js_1.signL1Action)({
                wallet: this.wallet,
                action,
                nonce,
                isTestnet: this.isTestnet,
            });
            // Send a request
            const request = { action, signature, nonce };
            const response = await this.transport.request("exchange", request, signal);
            // Validate a response
            this._validateResponse(response);
            return response;
        }
        /**
         * Delegate or undelegate native tokens to or from a validator.
         * @param args - The parameters for the request.
         * @param signal - An optional abort signal.
         * @returns Successful response without specific data.
         * @throws {ApiRequestError} When the API returns an error response.
         *
         * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#delegate-or-undelegate-stake-from-validator
         * @example
         * ```ts
         * import * as hl from "@nktkas/hyperliquid";
         * import { privateKeyToAccount } from "viem/accounts";
         *
         * const wallet = privateKeyToAccount("0x...");
         * const transport = new hl.HttpTransport(); // or WebSocketTransport
         * const client = new hl.WalletClient({ wallet, transport });
         *
         * const result = await client.tokenDelegate({
         *   validator: "0x...",
         *   isUndelegate: true,
         *   wei: 1 * 1e8,
         * });
         * ```
         */
        async tokenDelegate(args, signal) {
            // Construct an action
            const action = {
                ...args,
                type: "tokenDelegate",
                hyperliquidChain: this._getHyperliquidChain(),
                signatureChainId: await this._getSignatureChainId(),
                nonce: await this.nonceManager(),
            };
            // Sign the action
            const signature = await (0, signing_js_1.signUserSignedAction)({
                wallet: this.wallet,
                action,
                types: {
                    "HyperliquidTransaction:TokenDelegate": [
                        { name: "hyperliquidChain", type: "string" },
                        { name: "validator", type: "address" },
                        { name: "wei", type: "uint64" },
                        { name: "isUndelegate", type: "bool" },
                        { name: "nonce", type: "uint64" },
                    ],
                },
                chainId: parseInt(action.signatureChainId, 16),
            });
            // Send a request
            const request = { action, signature, nonce: action.nonce };
            const response = await this.transport.request("exchange", request, signal);
            // Validate a response
            this._validateResponse(response);
            return response;
        }
        /**
         * Cancel a TWAP order.
         * @param args - The parameters for the request.
         * @param signal - An optional abort signal.
         * @returns Successful variant of {@link TwapCancelResponse} without error status.
         * @throws {ApiRequestError} When the API returns an error response.
         *
         * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#cancel-a-twap-order
         * @example
         * ```ts
         * import * as hl from "@nktkas/hyperliquid";
         * import { privateKeyToAccount } from "viem/accounts";
         *
         * const wallet = privateKeyToAccount("0x...");
         * const transport = new hl.HttpTransport(); // or WebSocketTransport
         * const client = new hl.WalletClient({ wallet, transport });
         *
         * const result = await client.twapCancel({
         *   a: 0, // Asset index
         *   t: 1, // TWAP ID
         * });
         * ```
         */
        async twapCancel(args, signal) {
            // Destructure the parameters
            const { vaultAddress = this.defaultVaultAddress, expiresAfter = await this._getDefaultExpiresAfter(), ...actionArgs } = args;
            // Construct an action
            const nonce = await this.nonceManager();
            const action = {
                type: "twapCancel",
                a: actionArgs.a,
                t: actionArgs.t,
            };
            // Sign the action
            const signature = await (0, signing_js_1.signL1Action)({
                wallet: this.wallet,
                action,
                nonce,
                isTestnet: this.isTestnet,
                vaultAddress,
                expiresAfter,
            });
            // Send a request
            const request = { action, signature, nonce, vaultAddress, expiresAfter };
            const response = await this.transport.request("exchange", request, signal);
            // Validate a response
            this._validateResponse(response);
            return response;
        }
        /**
         * Place a TWAP order.
         * @param args - The parameters for the request.
         * @param signal - An optional abort signal.
         * @returns Successful variant of {@link TwapOrderResponse} without error status.
         * @throws {ApiRequestError} When the API returns an error response.
         *
         * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#place-a-twap-order
         * @example
         * ```ts
         * import * as hl from "@nktkas/hyperliquid";
         * import { privateKeyToAccount } from "viem/accounts";
         *
         * const wallet = privateKeyToAccount("0x...");
         * const transport = new hl.HttpTransport(); // or WebSocketTransport
         * const client = new hl.WalletClient({ wallet, transport });
         *
         * const result = await client.twapOrder({
         *   a: 0, // Asset index
         *   b: true, // Buy order
         *   s: "1", // Size
         *   r: false, // Not reduce-only
         *   m: 10, // Duration in minutes
         *   t: true, // Randomize order timing
         * });
         * ```
         */
        async twapOrder(args, signal) {
            // Destructure the parameters
            const { vaultAddress = this.defaultVaultAddress, expiresAfter = await this._getDefaultExpiresAfter(), ...actionArgs } = args;
            // Construct an action
            const nonce = await this.nonceManager();
            const action = {
                type: "twapOrder",
                twap: {
                    a: actionArgs.a,
                    b: actionArgs.b,
                    s: this._formatDecimal(actionArgs.s),
                    r: actionArgs.r,
                    m: actionArgs.m,
                    t: actionArgs.t,
                },
            };
            // Sign the action
            const signature = await (0, signing_js_1.signL1Action)({
                wallet: this.wallet,
                action,
                nonce,
                isTestnet: this.isTestnet,
                vaultAddress,
                expiresAfter,
            });
            // Send a request
            const request = { action, signature, nonce, vaultAddress, expiresAfter };
            const response = await this.transport.request("exchange", request, signal);
            // Validate a response
            this._validateResponse(response);
            return response;
        }
        /**
         * Add or remove margin from isolated position.
         * @param args - The parameters for the request.
         * @param signal - An optional abort signal.
         * @returns Successful response without specific data.
         * @throws {ApiRequestError} When the API returns an error response.
         *
         * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#update-isolated-margin
         * @example
         * ```ts
         * import * as hl from "@nktkas/hyperliquid";
         * import { privateKeyToAccount } from "viem/accounts";
         *
         * const wallet = privateKeyToAccount("0x...");
         * const transport = new hl.HttpTransport(); // or WebSocketTransport
         * const client = new hl.WalletClient({ wallet, transport });
         *
         * const result = await client.updateIsolatedMargin({ asset: 0, isBuy: true, ntli: 1 * 1e6 });
         * ```
         */
        async updateIsolatedMargin(args, signal) {
            // Destructure the parameters
            const { vaultAddress = this.defaultVaultAddress, expiresAfter = await this._getDefaultExpiresAfter(), ...actionArgs } = args;
            // Construct an action
            const nonce = await this.nonceManager();
            const action = {
                type: "updateIsolatedMargin",
                asset: actionArgs.asset,
                isBuy: actionArgs.isBuy,
                ntli: actionArgs.ntli,
            };
            // Sign the action
            const signature = await (0, signing_js_1.signL1Action)({
                wallet: this.wallet,
                action,
                nonce,
                isTestnet: this.isTestnet,
                vaultAddress,
                expiresAfter,
            });
            // Send a request
            const request = { action, signature, nonce, vaultAddress, expiresAfter };
            const response = await this.transport.request("exchange", request, signal);
            // Validate a response
            this._validateResponse(response);
            return response;
        }
        /**
         * Update cross or isolated leverage on a coin.
         * @param args - The parameters for the request.
         * @param signal - An optional abort signal.
         * @returns Successful response without specific data.
         * @throws {ApiRequestError} When the API returns an error response.
         *
         * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#update-leverage
         * @example
         * ```ts
         * import * as hl from "@nktkas/hyperliquid";
         * import { privateKeyToAccount } from "viem/accounts";
         *
         * const wallet = privateKeyToAccount("0x...");
         * const transport = new hl.HttpTransport(); // or WebSocketTransport
         * const client = new hl.WalletClient({ wallet, transport });
         *
         * const result = await client.updateLeverage({ asset: 0, isCross: true, leverage: 5 });
         * ```
         */
        async updateLeverage(args, signal) {
            // Destructure the parameters
            const { vaultAddress = this.defaultVaultAddress, expiresAfter = await this._getDefaultExpiresAfter(), ...actionArgs } = args;
            // Construct an action
            const nonce = await this.nonceManager();
            const action = {
                type: "updateLeverage",
                asset: actionArgs.asset,
                isCross: actionArgs.isCross,
                leverage: actionArgs.leverage,
            };
            // Sign the action
            const signature = await (0, signing_js_1.signL1Action)({
                wallet: this.wallet,
                action,
                nonce,
                isTestnet: this.isTestnet,
                vaultAddress,
                expiresAfter,
            });
            // Send a request
            const request = { action, signature, nonce, vaultAddress, expiresAfter };
            const response = await this.transport.request("exchange", request, signal);
            // Validate a response
            this._validateResponse(response);
            return response;
        }
        /**
         * Transfer funds between Spot account and Perp account.
         * @param args - The parameters for the request.
         * @param signal - An optional abort signal.
         * @returns Successful response without specific data.
         * @throws {ApiRequestError} When the API returns an error response.
         *
         * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#transfer-from-spot-account-to-perp-account-and-vice-versa
         * @example
         * ```ts
         * import * as hl from "@nktkas/hyperliquid";
         * import { privateKeyToAccount } from "viem/accounts";
         *
         * const wallet = privateKeyToAccount("0x...");
         * const transport = new hl.HttpTransport(); // or WebSocketTransport
         * const client = new hl.WalletClient({ wallet, transport });
         *
         * const result = await client.usdClassTransfer({ amount: "1", toPerp: true });
         * ```
         */
        async usdClassTransfer(args, signal) {
            // Construct an action
            const action = {
                ...args,
                type: "usdClassTransfer",
                hyperliquidChain: this._getHyperliquidChain(),
                signatureChainId: await this._getSignatureChainId(),
                nonce: await this.nonceManager(),
            };
            // Sign the action
            const signature = await (0, signing_js_1.signUserSignedAction)({
                wallet: this.wallet,
                action,
                types: {
                    "HyperliquidTransaction:UsdClassTransfer": [
                        { name: "hyperliquidChain", type: "string" },
                        { name: "amount", type: "string" },
                        { name: "toPerp", type: "bool" },
                        { name: "nonce", type: "uint64" },
                    ],
                },
                chainId: parseInt(action.signatureChainId, 16),
            });
            // Send a request
            const request = { action, signature, nonce: action.nonce };
            const response = await this.transport.request("exchange", request, signal);
            // Validate a response
            this._validateResponse(response);
            return response;
        }
        /**
         * Send usd to another address.
         * @param args - The parameters for the request.
         * @param signal - An optional abort signal.
         * @returns Successful response without specific data.
         * @throws {ApiRequestError} When the API returns an error response.
         *
         * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#core-usdc-transfer
         * @example
         * ```ts
         * import * as hl from "@nktkas/hyperliquid";
         * import { privateKeyToAccount } from "viem/accounts";
         *
         * const wallet = privateKeyToAccount("0x...");
         * const transport = new hl.HttpTransport(); // or WebSocketTransport
         * const client = new hl.WalletClient({ wallet, transport });
         *
         * const result = await client.usdSend({ destination: "0x...", amount: "1" });
         * ```
         */
        async usdSend(args, signal) {
            // Construct an action
            const action = {
                ...args,
                type: "usdSend",
                hyperliquidChain: this._getHyperliquidChain(),
                signatureChainId: await this._getSignatureChainId(),
                time: await this.nonceManager(),
            };
            // Sign the action
            const signature = await (0, signing_js_1.signUserSignedAction)({
                wallet: this.wallet,
                action,
                types: {
                    "HyperliquidTransaction:UsdSend": [
                        { name: "hyperliquidChain", type: "string" },
                        { name: "destination", type: "string" },
                        { name: "amount", type: "string" },
                        { name: "time", type: "uint64" },
                    ],
                },
                chainId: parseInt(action.signatureChainId, 16),
            });
            // Send a request
            const request = { action, signature, nonce: action.time };
            const response = await this.transport.request("exchange", request, signal);
            // Validate a response
            this._validateResponse(response);
            return response;
        }
        /**
         * Distribute funds from a vault between followers.
         * @param args - The parameters for the request.
         * @param signal - An optional abort signal.
         * @returns Successful response without specific data.
         * @throws {ApiRequestError} When the API returns an error response.
         *
         * @see null - no documentation
         * @example
         * ```ts
         * import * as hl from "@nktkas/hyperliquid";
         * import { privateKeyToAccount } from "viem/accounts";
         *
         * const wallet = privateKeyToAccount("0x...");
         * const transport = new hl.HttpTransport(); // or WebSocketTransport
         * const client = new hl.WalletClient({ wallet, transport });
         *
         * const result = await client.vaultDistribute({ vaultAddress: "0x...", usd: 10 * 1e6 });
         * ```
         */
        async vaultDistribute(args, signal) {
            // Construct an action
            const nonce = await this.nonceManager();
            const action = {
                type: "vaultDistribute",
                vaultAddress: args.vaultAddress,
                usd: args.usd,
            };
            // Sign the action
            const signature = await (0, signing_js_1.signL1Action)({
                wallet: this.wallet,
                action,
                nonce,
                isTestnet: this.isTestnet,
            });
            // Send a request
            const request = { action, signature, nonce };
            const response = await this.transport.request("exchange", request, signal);
            // Validate a response
            this._validateResponse(response);
            return response;
        }
        /**
         * Modify a vault's configuration.
         * @param args - The parameters for the request.
         * @param signal - An optional abort signal.
         * @returns Successful response without specific data.
         * @throws {ApiRequestError} When the API returns an error response.
         *
         * @see null - no documentation
         * @example
         * ```ts
         * import * as hl from "@nktkas/hyperliquid";
         * import { privateKeyToAccount } from "viem/accounts";
         *
         * const wallet = privateKeyToAccount("0x...");
         * const transport = new hl.HttpTransport(); // or WebSocketTransport
         * const client = new hl.WalletClient({ wallet, transport });
         *
         * const result = await client.vaultModify({
         *   vaultAddress: "0x...",
         *   allowDeposits: true,
         *   alwaysCloseOnWithdraw: false,
         * });
         * ```
         */
        async vaultModify(args, signal) {
            // Construct an action
            const nonce = await this.nonceManager();
            const action = {
                type: "vaultModify",
                vaultAddress: args.vaultAddress,
                allowDeposits: args.allowDeposits,
                alwaysCloseOnWithdraw: args.alwaysCloseOnWithdraw,
            };
            // Sign the action
            const signature = await (0, signing_js_1.signL1Action)({
                wallet: this.wallet,
                action,
                nonce,
                isTestnet: this.isTestnet,
            });
            // Send a request
            const request = { action, signature, nonce };
            const response = await this.transport.request("exchange", request, signal);
            // Validate a response
            this._validateResponse(response);
            return response;
        }
        /**
         * Deposit or withdraw from a vault.
         * @param args - The parameters for the request.
         * @param signal - An optional abort signal.
         * @returns Successful response without specific data.
         * @throws {ApiRequestError} When the API returns an error response.
         *
         * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#deposit-or-withdraw-from-a-vault
         * @example
         * ```ts
         * import * as hl from "@nktkas/hyperliquid";
         * import { privateKeyToAccount } from "viem/accounts";
         *
         * const wallet = privateKeyToAccount("0x...");
         * const transport = new hl.HttpTransport(); // or WebSocketTransport
         * const client = new hl.WalletClient({ wallet, transport });
         *
         * const result = await client.vaultTransfer({
         *   vaultAddress: "0x...",
         *   isDeposit: true,
         *   usd: 10 * 1e6,
         * });
         * ```
         */
        async vaultTransfer(args, signal) {
            // Destructure the parameters
            const { expiresAfter = await this._getDefaultExpiresAfter(), ...actionArgs } = args;
            // Construct an action
            const nonce = await this.nonceManager();
            const action = {
                type: "vaultTransfer",
                vaultAddress: actionArgs.vaultAddress,
                isDeposit: actionArgs.isDeposit,
                usd: actionArgs.usd,
            };
            // Sign the action
            const signature = await (0, signing_js_1.signL1Action)({
                wallet: this.wallet,
                action,
                nonce,
                isTestnet: this.isTestnet,
                expiresAfter,
            });
            // Send a request
            const request = { action, signature, nonce, expiresAfter };
            const response = await this.transport.request("exchange", request, signal);
            // Validate a response
            this._validateResponse(response);
            return response;
        }
        /**
         * Initiate a withdrawal request.
         * @param args - The parameters for the request.
         * @param signal - An optional abort signal.
         * @returns Successful response without specific data.
         * @throws {ApiRequestError} When the API returns an error response.
         *
         * @see https://hyperliquid.gitbook.io/hyperliquid-docs/for-developers/api/exchange-endpoint#initiate-a-withdrawal-request
         * @example
         * ```ts
         * import * as hl from "@nktkas/hyperliquid";
         * import { privateKeyToAccount } from "viem/accounts";
         *
         * const wallet = privateKeyToAccount("0x...");
         * const transport = new hl.HttpTransport(); // or WebSocketTransport
         * const client = new hl.WalletClient({ wallet, transport });
         *
         * const result = await client.withdraw3({ destination: "0x...", amount: "1" });
         * ```
         */
        async withdraw3(args, signal) {
            // Construct an action
            const action = {
                ...args,
                type: "withdraw3",
                hyperliquidChain: this._getHyperliquidChain(),
                signatureChainId: await this._getSignatureChainId(),
                time: await this.nonceManager(),
            };
            // Sign the action
            const signature = await (0, signing_js_1.signUserSignedAction)({
                wallet: this.wallet,
                action,
                types: {
                    "HyperliquidTransaction:Withdraw": [
                        { name: "hyperliquidChain", type: "string" },
                        { name: "destination", type: "string" },
                        { name: "amount", type: "string" },
                        { name: "time", type: "uint64" },
                    ],
                },
                chainId: parseInt(action.signatureChainId, 16),
            });
            // Send a request
            const request = { action, signature, nonce: action.time };
            const response = await this.transport.request("exchange", request, signal);
            // Validate a response
            this._validateResponse(response);
            return response;
        }
        /** Formats a decimal number as a string, removing trailing zeros. */
        _formatDecimal(numStr) {
            if (!numStr.includes("."))
                return numStr;
            const [intPart, fracPart] = numStr.split(".");
            const newFrac = fracPart.replace(/0+$/, "");
            return newFrac ? `${intPart}.${newFrac}` : intPart;
        }
        /** Guesses the chain ID based on the wallet type or the isTestnet flag. */
        async _guessSignatureChainId() {
            // Trying to get chain ID of the wallet
            if ((0, signing_js_1.isAbstractViemWalletClient)(this.wallet) || (0, signing_js_1.isAbstractExtendedViemWalletClient)(this.wallet)) {
                if ("getChainId" in this.wallet && typeof this.wallet.getChainId === "function") {
                    const chainId = await this.wallet.getChainId();
                    return `0x${chainId.toString(16)}`;
                }
            }
            else if ((0, signing_js_1.isAbstractEthersSigner)(this.wallet) || (0, signing_js_1.isAbstractEthersV5Signer)(this.wallet)) {
                if ("provider" in this.wallet &&
                    typeof this.wallet.provider === "object" && this.wallet.provider !== null &&
                    "getNetwork" in this.wallet.provider &&
                    typeof this.wallet.provider.getNetwork === "function") {
                    const network = await this.wallet.provider.getNetwork();
                    return `0x${network.chainId.toString(16)}`;
                }
            }
            else if ((0, signing_js_1.isAbstractWindowEthereum)(this.wallet)) {
                const [chainId] = await this.wallet.request({ method: "eth_chainId", params: [] });
                return chainId;
            }
            // Attempt to guess chain ID based on isTestnet
            return this.isTestnet ? "0x66eee" : "0xa4b1";
        }
        /** Get the default expiration time for an action. */
        async _getDefaultExpiresAfter() {
            return typeof this.defaultExpiresAfter === "number"
                ? this.defaultExpiresAfter
                : await this.defaultExpiresAfter?.();
        }
        /** Get the signature chain ID for the wallet. */
        async _getSignatureChainId() {
            return typeof this.signatureChainId === "string" ? this.signatureChainId : await this.signatureChainId();
        }
        /** Get the Hyperliquid chain based on the isTestnet flag. */
        _getHyperliquidChain() {
            return this.isTestnet ? "Testnet" : "Mainnet";
        }
        /** Validate a response from the API. */
        _validateResponse(response) {
            if (response.status === "err") {
                throw new ApiRequestError(response);
            }
            else if (response.response.type === "order" || response.response.type === "cancel") {
                if (response.response.data.statuses.some((status) => typeof status === "object" && "error" in status)) {
                    throw new ApiRequestError(response);
                }
            }
            else if (response.response.type === "twapOrder" || response.response.type === "twapCancel") {
                if (typeof response.response.data.status === "object" && "error" in response.response.data.status) {
                    throw new ApiRequestError(response);
                }
            }
        }
        async [Symbol.asyncDispose]() {
            await this.transport[Symbol.asyncDispose]?.();
        }
    }
    exports.WalletClient = WalletClient;
});
